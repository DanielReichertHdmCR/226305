---
title: "226503 Blocktag"
subtitle: "Übung Visualisierung"
author: "Swaran Sandhu"
date: "2020-10-06"
---

# Setup für Markdown Ausgabe

```{r setup markdown, include=FALSE}
library(rmarkdown) # lädt die Markdown-Dateien
```


# Konventionen
Das Fallbeispiel ist ein fiktives Studentennetzwerk mit 38 Knoten Siehe das Codebuch auf github für weitere Informationen. Sie brauchen die Infos aus dem Codebuch für die Analyse!

https://github.com/hdm-crpr/226305/blob/master/data/crpr2/codebuch.md

*Wichtige Spielregeln*
1. Achten Sie darauf, dass Sie immer mit dem richtigen Netzwerk arbeiten.
2. Die Querbezüge innerhalb eines Skripts sind elementar.
3. Kommentieren Sie den Code, damit er nachvollziehbar für Sie und Dritte bleibt!
4. Wenn Sie das Netzwerk modifizieren, erstellen sie ein neues Netzwerk mit einem eindeutigen Namen, auf das sie sich beziehen können. Achtung: alle Referenzierungen im Code müssen sich immer auf das aktuelle Netzwerk beziehen.
5. Löschen Sie regelmäßig die Daten, die im Environment gespeichert sind.
6. Generieren Sie für eine neue Analyse ein neues Netzwerk. 
7. Es gibt meistens mehrere Lösungen für ein Problem. 
8. Save early, save often.
9. Fragen Sie Kommilitonen, Documentation, Tutorials, Stackoverflow, etc.


#############################################
# Block 1: Visualisierung und Teilnetzwerke #
#############################################

# Grundlegende Visualisierungen

## Notwendige Pakete installieren

```{r Pakete installieren}
library(igraph)
```


## Erstellung und Visualisierung des igraph Objekts

```{r igraph Objekt erstellen }
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")
edgematrix <-as.matrix(el)
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)
s
edge.attributes(s)
plot(s,
     layout=layout_with_kk,
     main ="out-of-the-box Visualisierung des Netzwerks")
```

## Modifikation (dauerhaft) von Attributen des Netzwerks
Jedes Netzwerk hat zusätzlich zu den erhobenen Attributen feststehende Visualisierungsparameter. Diese lassen sich beliebig manipulieren. Werden die Daten ein Mal festgeschrieben, dann gelten sie für alle weiteren Netzwerke. Achtung: die Visualisierungsparameter im Befehl plot() überschreiben nur für die Visualisierung die festgelegten Parameter.

Merke: Die Befehle V(g) und E(g) erstellen dauerhaft neue Vertex bzw. Edge-Attribute, die mit bestimmten Eigenschaften versehen werden können. Mit $ wird auf die entsprechenden Attribute zugegriffen.Die Attribute lassen sich auch durch "NA" komplett löschen oder durch ein bestehendes Attribut wieder ergänzen.

## Modifikation der Vertices (Knoten oder Nodes)

```{r Veränderung von Vertex-Attributen}

# Anzeige der möglichen Attribute in igraph
?igraph.plotting

# Veränderung der Füllfarbe des Vertex
V(s)$color <- "darkorange"

# blendet den Rahmen um den Vertex aus.
V(s)$frame.color <- "NA" 

# Veränderung des Labels
V(s)$label <- NA 
# blendet den Rahmen um den Vertex aus.
# dieser Befehl kann wie folgt zurückgesetzt werden
# V(s)$label <- V(s)$name

```

Analog dazu lassen sich die Edge-Attribute verändert.
Wichtig: die zu modifizierenden Attribute sind in ?igraph.plotting
hinterlegt. Da dies nur im plot() Befehl funktioniert, muss deshalb für die Befehle V(g) die Kennung vertex und für E(g) die Kennung edge weggelassen werden.

```{r Modifikation von Edge-Attributen}
# Modifikation der Edges

# setzt kleine Pfeilspitzen
E(s)$arrow.size <- .2 

# definiert die Farbe aller Kanten
E(s)$color <- "darkorange"
```

## Überschrift und Unterüberschrift hinzufügen
Die Überschriften werden im Befehl plot() durch main = "XX" für die Hauptüberschrift über der Abbildung und durch sub = "XY" für die Unterüberschrift definiert. Ein Zeilenumbruch wird durch \n erzeugt.


```{r Einfache Visualisierung}
plot(s,
     layout=layout_with_kk,
     main = "Studentennetzwerk",
     sub = "n=38, Layout mit Kamada-Kawai\n ohne Labels, Farbe darkorange")
```

```{r Volles Ausnutzen des Visualisierungsraums}
# Liest das Netzwerk erneut ein
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")
edgematrix <-as.matrix(el)
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)
s

# setzt die Ränder (margins) auf 0, schneidet aber manchmal dadurch die Überschrift ab
par(mar=c(0,0,0,0)) 

plot(s,
     asp=0, #definiert, dass der gesamte Raum ausgenutzt werden soll
     layout=layout_with_kk,
     vertex.size=10,
     edge.arrow.size=.4,
     edge.color="grey50",
     edge.curved=curve_multiple(s))

par(mar=c(0,0.5,0.5,0)) # setzt die Ränder zurück.
```





## Übungsaufgabe

Nennen Sie das bestehende Netzwerk um in "s_fff".

Verändern Sie das Netzwerk nach folgenden Parametern
* Knotenfarbe "lightgreen"
* Rahmenfarbe des Knotens "grey80"
* Kantenfarbe "grey80"
* Pfeilspitze "0.5"
* Labels wieder anzeigen
* Hauptüberschrift "Studentennetzwerk 2019"
* Unterüberschrift "n=38, Teilnahme Fridays for Future 2019"
* Visualisierung mit fruchterman-rheingold layout_with_fr

```{r Übungsaufgabe 1: Vertex/Edge-Attribute abändern}

el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")
edgematrix <-as.matrix(el)
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)
s

```

# Netzwerke nach Attributen selektieren
Alle Netzwerke lassen sich nach Attributen selektieren. Mit dem list() Befehl lassen sich die Edge- und Vertex-Attribute auflisten. Diese entsprechen den Spalten in der Edge- bzw. Nodelist.

```{r Netzwerkattribute auflisten}
list.edge.attributes(s)
list.vertex.attributes(s)
```

Wir kennen jetzt die Attribute des Netzwerks (genaugenommen kennen wir sie schon vorher, weil sie ja im Codebuch stehen).

https://github.com/hdm-crpr/226305/blob/master/data/crpr2/codebuch.md

R verwendet das *$-Zeichen* als shortcut für die Auswahl der Attribute graph_attr und set_graph_attr. Immer, wenn wir den $ einsetzen bedeutet dies in igraph, dass wir mit den Attributen des Netzwerks arbeiten. Der Syntax ist einfach, allerdings müssen die Bezeichnungen der Attribute vorher bekannt sein. Das gilt sowohl für Vertex als auch für Edge-Attribute.

*Merksatz*
Merksatz für igraph: $ wählt ein Attribut aus der (vorhandenen!) Attributsliste aus. Die Attributslisten werden vorher aufgerufen.

```{r Auswahl Edge-Attribute}
edge.attributes(s)$weight

# Aufgabe: zeigen Sie die Werte für das Attribute "relation" an.

```

"relation" ist ein wichtiges edge-attribut, da es die Netzwerke in das "work" (Wert 1) und das "help" (Wert 2) aufteilt (siehe Codebuch). Beide Werte können entweder den Wert 1 oder 3 annehmen. Der höhere Wert drückt eine stärkere Beziehungsintensität aus. Mit der späteren Aufteilung in zwei Unternetzwerke kann damit ein Vergleich der Netzwerke erstellt werden.

```{r Auswahl eines Vertex-Attributs}

# zeigt eine Liste aller Vertex-Attribute des Netzwerks an
list.vertex.attributes(s)

# liefert die Werte der Vertex-Attribute
vertex.attributes(s)

# liefert die Werte eines spezifischen Attributs
vertex.attributes(s)$sex
```

## igraph-Objekte vereinfachen

Mit dem simplify() Befehl lassen sich Netzwerke vereinfachen. Der Befehl löscht zum einen self-loops, d.h. Beziehungen, die auf den Knoten selbst gerichtet sind oder addiert die Werte des weight auf, sofern diese in der gleichen Relation stehen. Damit lässt sich die Anzahl der Kanten reduzieren, sofern doppelte Beziehungen genannt wurden.

In unserem Netzwerk sind zwei bekannte Relationen definiert: Projektzusammenarbeit (work) und Ratsuche (help). Beide können ein Gewicht von 3 (erste Nennung) oder 1 (zweite Nennung) annehmen. Dies bedeutet, dass z.B. die Beziehung zwischen zwei Knoten in eine Richtung den Minimal-Wert von 1 annahmen kann (in einer Relation z.B Zusammenarbeit wurde die Person als zweites genannt) und maximal 6 (in beiden Beziehungen (Ratsuche und Zusammenarbeit) wurde die Person als erstes genannt). Um das Netzwerk besser zu verstehen, lassen sich die Kantengewichte, die in der gleichen Beziehung stehen, mit dem Befehl edge.attr.comb (also verbinde die Edge-Attribute) als summarische Funktion abbilden.


```{r Netzwerk vereinfachen, weight aufaddieren}
# Wir erstellen das Ausgangsnetzwerk nochmals neu, da durch die obige Ergänzung der Edge-Attribute die Edge-Attribute nicht mehr numerisch waren. 

library(igraph)

el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")
edgematrix <-as.matrix(el)
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)
s

# Zur Vereinfachung wollen wir nur die Gewichte der Beziehungen der Netzwerke help und work aufaddieren. Dazu müssen wir zunächst die zusätzlichen Edge-Attribute love in $relation und das edge-attribute complicated löschen, da complicated als NA codiert wurde (nicht alle Beziehungen haben die Werte von complicated)

list.edge.attributes(s)
edge.attributes(s)

# Das Edge-Attribut "relation" hat jetzt noch die Werte der Kategorie 1=work, 2=help und 3=love. Da wir nicht die Gewichte von "love" mitaufkalkulieren wollen, löschen wir die Knoten, die die Kategorie 3 als Edge-Attribute in relation genannt haben. Dazu benötigen wir den Befehl subgraph.edges()

s_hw_clean <- subgraph.edges(s_hw_clean, E(s_hw_clean)[relation<3]) # löscht alle Werte über dem Wert 3. 
edge.attributes(s_hw_clean)$relation 

# Das Netzwerk hat jetzt die Ausgangskonfiguration mit 38 Knoten und 152 Kanten!
# Der Wert 152 ergibt sich aus der Beantwortung der vier Fragen zu Zusammenarbeit und Ratsuche
38*2*2

# Kontrolliert, ob die Daten sauber erstellt wurden 
list.edge.attributes(s_hw_clean)
edge.attributes(s_hw_clean)

# Anwendung des simplify-Befehl 

# mit dem simplify-Befehl werden gleiche Kanten aufaddiert und als Gewicht eingetragen. Der Befehl list(weight="sum") funktioniert nur bei numerischen Werten. Deshalb haben wir die Werte NA vorher bereinigt und das Edge-Attribut gelöscht.

s_simpl <- simplify(s_hw_clean, 
                    remove.multiple=TRUE, 
                    edge.attr.comb=list(weight="sum"))

# Analyse des neuen Netzwerks
s_simpl
ecount(s_simpl)
edge.attributes(s_simpl)$weight
# Dadurch verändert sich auch die Anzahl der Edges von 152 auf 116, da gleiche Beziehungen entsprechend aufaddiert wurden.

plot(s_simpl,
     edge.arrow.size=0.2, # kleine Pfeilspitzen
     edge.curved=0.2, # leichte Krümmung der Kanten
     edge.color="red", # Kanten in rot
     vertex.color="red", # Knoten in rot
     vertex.frame.color="red", # Knotenrahmen in rot
     vertex.label.color="white", # Label in weiss
     layout=layout_with_kk, # layout mit Kamada-Kawai
     vertex.size=degree(s_simpl)*1.5, # definiert die Größe der Knoten nach degree und multipliziert den Wert mit 1.5, damit die Darstellung besser wird
     edge.width=E(s_simpl)$weight/2, # Kantenstärke als aufaddiertes Gewicht
     main="Beispielnetzwerk (simplified)", 
     sub="Edges aufaddiert, dadurch nur noch 116 edges")
```


# Visualisierung nach Vertex-Attributen

## Einzelne Attribute visualisieren

Um einzelne Attribute dauerhaft zu selektieren lassen sich entweder existierende Werte verändern oder neue Werte hinzufügen. Vertex-Attribute werden mit dem Großbuchstaben V(g) gekennzeichnet, Edge-Attribute entsprechend mit dem Großbuchstaben E(g). Neue Attribute werden erneut mit der Abkürzung $ ergänzt. Achtung: wenn neue Attribute ergänzt werden, dann werden diese dauerhaft ergänzt.


```{r Vertex-Attribute dauerhaft ergänzen}
# Wir erstellen das Ausgangsnetzwerk nochmals neu, da durch die obige Ergänzung der Edge-Attribute die Edge-Attribute nicht mehr numerisch waren. 

el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")
edgematrix <-as.matrix(el)
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)
s

# erstellt das Vertex-Attribut "color" und weist um das Attribut "blau" zu
V(s)$color <- "lightblue"

# ruft das Vertex-Attribut auf
vertex.attributes(s)$color

par(mfrow=c(1,2), mar=c(0,0,2,1)) # definiert, dass zwei Abbildungen in einer Zeile stehen

# zeigt eine Grafik
plot(s, 
     edge.arrow.size=.3, 
     layout=layout_with_kk, 
     main="Vollerhebung blau",
     sub="Vertex-Attribut color auf Farbe lightblue gesetzt")

# setzt das Attribut wieder zurück auf gelb, denn das Attribut wird jetzt dauerhaft so verwendet.
V(s)$color <- "gold"
plot(s, 
     edge.arrow.size=.3, 
     layout=layout_with_kk, 
     main="Vollerhebung gold",
     sub="Vertex-Attribut color zurück auf gold")

par(mfrow=c(1,1), mar=c(0,0,2,1)) # setzt die Abbildung wieder zurück

# Übungsaufgabe
# Verändern Sie die Vertex-Farbe in "green" und die Edge-Farbe in "blue"


```

# Visualisierung nach Edge-Attributen

Edge-Attribute isolieren und verändern (multiplexe Netzwerke)

*Multiplexe Netzwerke: zwei Typen von Kanten in einem Netzwerk*
Multiplexe Netzwerke haben mehr als nur eine Kantenart, d.h. es werden mehrere Beziehungsarten im gleichen Graphen visualisiert. Dazu gibt es zwei Möglichkeiten (die sich auch kombinieren lassen): Farben und Formen. Achtung: multiplexe Netzwerke werden leicht unübersichtlich, deshalb sollte die Visualisierung immer mit Bedacht vorgenommen werden.

1) *Kantenfarben* verwenden: wir haben in dem Edge-Attribut "relation" zwei Werte angebgeben, nämlich "1" (work) und "2" (help), die unterschiedliche Beziehungen beschreiben. Die Kanten lassen sich entsprechend einfärben.


```{r Multiplexe Netzwerke: Kantenfarben verwenden}

# Wir lesen das Netzwerk neu ein
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")
edgematrix <-as.matrix(el)
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)
s

# definiert die Kantenfarben nach dem Edge-Attribut relation
E(s)[E(s)$relation == 1]$color <- "blue" # working together (work)
E(s)[E(s)$relation == 2]$color <- "green" # support (help)
E(s)[E(s)$relation == 3]$color <- "red" # relationship (love)

# Visualisierung des multiplexen Netzwerks
plot(s,
     edge.arrow.size=.1,
     vertex.color="gray90",
     vertex.frame.color="white",
     layout=layout_with_kk,
     edge.curved=curve_multiple(s),
     main="Multiplexes Netzwerk, d.h. verschiedene Formen der Beziehung",
     sub="n=38, blau=Zusammenarbeit, grün=Ratsuche, rot=Beziehung")

# das Attribut curve_multiple beim Befehl edge.curved verhindert, dass sich die einzelnen edges direkt überlagern und erleichtert so die Sichtbarkeit der einzelnen Kanten.

# Der edge.color Befehl bezieht sich auf einen Vektor, der genau zwei Werte hat (Das Edge-Attribut Relation hat den Wert 1 und 2). Die Farbwerte "blue" und "green" werden dann auf die Edge-Attribute edge.color 1 und 2 angewendet.

```

```{r Übung: Selektion und Einfärben von Beziehungskategorien}

# Übungsaufgabe
# 1. Visualisieren Sie nur das Zusammenarbeitsnetzwerk work in blau (alles andere schwarz)
# 2. Visualisieren Sie nur das Beziehungsnetzwerk love in rot (alles andere schwarz)

# Wir lesen das Netzwerk neu ein
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")
edgematrix <-as.matrix(el)
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)
s

# und wie geht es weiter?

```


## Einfärben von Vertex-Attributen
Ähnlich wie die edge-Attribute lassen sich auch Visualisierungen für die Vertex-Attribute durchführen. Dazu können die numerisch codierten Vertex-Attribute eingesetzt werden.


```{r Einfärben nach Vertex-Attributen}

# Wir lesen das Netzwerk neu ein
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")
edgematrix <-as.matrix(el)
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)
s

# definiert die Kantenfarben nach dem Edge-Attribut relation
V(s)[V(s)$sex == 1]$color <- "pink" # weiblich
V(s)[V(s)$sex == 2]$color <- "lightblue" # männlich
V(s)[V(s)$sex == 3]$color <- "yellow" # divers

# Visualisierung des Netzwerks nach Geschlechtsmerkmalen
plot(s,
     edge.arrow.size=.1,
     layout=layout_with_kk,
     edge.curved=curve_multiple(s),
     main="Netzwerk nach Geschlechtsmerkmalen",
     sub="n=38, pink=weiblich, blau=männlich, gelb=divers")

# markiert blaue Augen und schwarze haare
V(s)[V(s)$age==4]$frame.color <- "red" # generische Markierung

plot(s,
     edge.arrow.size=.1,
     layout=layout_with_kk,
     edge.curved=curve_multiple(s),
     main="Netzwerk nach Geschlechtsmerkmalen und Alter",
     sub="n=38, pink=weiblich, blau=männlich, gelb=divers \n rote Markerierung über 25 Jahre ")

```

# Sonderformate: Formen und Farben

R kennt als Standardeinstellung 657 Farbkennwerte mit Namen. Diese lassen sich meist einfach verwenden, indem direkt der Name des Farbwerts aufgerufen wird. Manchmal sind die Farbwerte fix, manchmal auch wie bei Grauwerten im Abstand von Prozentwerten definiert (z.B. grey60 bedeutet einen Grauwert von 60% des Standardgrau).

```{r Farben in R}
# die ersten 20 Farben in R anzeigen
r_color <- colors()
head(r_color, 20)

# Die Farbwerte als Demo anzeigen
#demo("colors")
```

Schöne fertige Farbpaletten liefern die Pakete RColorbrewer, die sich beonders gut für Verläufe eignen.

```{r Farbpaletten mir RColorBrewer}
library(RColorBrewer)
display.brewer.all()

```

### Formen für Vertices
Nodes werden in der Regel als Kreis gezeichnet. Insbesondere bei two-mode-Netzwerken ist es aber notwendig, diese Formen zu trennen. R kennt als Standard folgende Formen: “circle”, “square”, “csquare”, “rectangle”, “crectangle”, “vrectangle”. In der Regel haben two-mode Netzwerke zwei Formen, d.h. sie lassen sich leicht als Kreis und Quadrat darstellen. In unserem Beispiel werden wir Frauen, Männer und Divers in unterschiedlichen Formen darstellen.

```{r Vertex-Formen anpassen}
# Wir lesen das Netzwerk neu ein
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")
edgematrix <-as.matrix(el)
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)
s

# definiert die Kantenformen nach dem Edge-Attribut relation
V(s)[V(s)$sex == 1]$shape <- "circle" # weiblich
V(s)[V(s)$sex == 2]$shape <- "square" # männlich

# Visualisierung des Netzwerks nach Geschlechtsmerkmalen
plot(s,
     edge.arrow.size=.1,
     layout=layout_with_kk,
     edge.curved=curve_multiple(s),
     main="Netzwerk nach Geschlechtsmerkmalen",
     sub="n=38, Kreis = weiblich, Quadrat = männlich")
```

```{r Übung Formen anpassen}
# Wir lesen das Netzwerk neu ein
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")
edgematrix <-as.matrix(el)
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)
s

# definieren Sie alle Personen über 23 als Quadrate und alle Personen bis 23 als Kreise 


```


### Formen für Kanten
Neben den Vertex-Formaten lassen sich auch die Kanten visuell anpassen. Hier stehen verschiedene Formen zur Verfügung: 0 or “blank”, 1 or “solid”, 2 or “dashed”, 3 or “dotted”, 4 or “dotdash”, 5 or “longdash”, 6 or “twodash”. Die Codierung ist vorgegeben und als edge.lty definiert. lty steht für Linetype, also die Art der Linie, die verwendet wird.

```{r Kantenformen anpassen }

# Wir lesen das Netzwerk neu ein
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")
edgematrix <-as.matrix(el)
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)
s

# definiert die Kantenform nach dem Edge-Attribut relation
E(s)[E(s)$relation == 1]$lty <-2 # dashed (work)
E(s)[E(s)$relation == 2]$lty <-3 # dotted (help)
E(s)[E(s)$relation == 3]$lty <-4 # dotdash (love)

# Visualisierung des multiplexen Netzwerks
plot(s,
     edge.arrow.size=.1,
     edge.color="black",
     vertex.color="gray90",
     vertex.frame.color="white",
     layout=layout_with_kk,
     edge.curved=curve_multiple(s),
     main="Multiplexes Netzwerk, Format der Kanten",
     sub="n=38, work=dashed, help=dotted, love=dotdash")
```


# Selektion von Teilnetzwerken 

Ein einzelnes Netzwerk ist meistens nicht aussagekräftig. Wenn sich das Netzwerk nach bestimmten Kriterien aufteilen lässt, hilft dies bei der Analyse, um Unterschiede zu erkennen. Netzwerke lassen sich entweder nach Edge- oder Vertex-Attributen aufteilen oder eine Kombination davon.

Wichtig: überlegen Sie vor der Analyse, welche Schritte notwendig sind, um ein Netzwerk zu zerlegen. Manchmal braucht es mehrere Teilschritte und Kombinatorik, um zu einem bestimmten Ergebnis zu kommen. Am besten ist es, die Arbeitsschritte bei komplexeren Analysen schrittweise zu skizzieren, bevor es an die Auswertung geht.

*Merksatz*
Komplexe Selektionen von Netzwerken sind extrem hilfreich, benötigen aber eine saubere Vorüberlegung, welche Attribute in welcher Kombination selektiert werden sollen. 

## Selektion von Teilnetzwerken nach Edge-Attributen

### Kapitel 3.4.1 Vergleich zweier Netzwerke nach Edge-Attributen

Netzwerke lassen sich nach bestimmten Kriterien aufteilen. Wir haben im Edge-Attribut "relation" zwei Werte, 1 und 2, die das Ratsuche- und Zusammenarbeitsnetzwerk definieren (siehe Codebuch).

Um das Netzwerk entsprechend nach Edge-Attributen aufzutrennen, verwenden wir den Befehl *subgraph.edges()*. Hier werden aus einen Netzwerk entsprechende Unternetzwerke erstellt. In diesem Fall soll das neue Netzwerk "help" generiert werden, in dem alle Knoten und Kanten, die größer als 1 sind in das neue Netzwerk übertragen werden:


```{r Kapitel 3: Netzwerk mit subgraph.edges unterteilen}
# Netzwerk einlesen
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")
edgematrix <-as.matrix(el)
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)
s

# Erstellt das neue Netzwerk help, in dem nur alle Kanten verwendet werden, die einen Wert > 1 haben. Da der Wert 1 sich auf das Zusammenarbeitsnetzwerk bezieht, sind dies alle Unterstützungsnetzwerke. Alternativ lassen sich andere logische Operatoren verwenden.

work <- subgraph.edges(s, E(s)[relation==1]) 
work

plot(work,
     edge.arrow.size=.3,
     layout=layout_with_kk,
     edge.color="blue",
     edge.curved=.2,
     edge.curved=curve_multiple(work),
     main="Work-Netzwerk",
     sub="n=38, KK-Algorithmus")
```

Das neue Netzwerk hat jetzt 38 Knoten und 76 Kanten, ist also genau entlang dem Edge-Attribut "relation" geteilt. Zum Vergleich muss genau so noch das Zusammenarbeitsnetzwerk "help" erstellt werden. 

```{r Kapitel 3: Vergleichsnetzwerk Help erstellen}
help <- subgraph.edges(s, E(s)[relation==2]) 
help
plot(help)
# Netzwerk verschönern mit wenigen Befehlen
plot(help,
     edge.arrow.size=.3,
     layout=layout_with_kk,
     edge.color="green",
     edge.curved=.2,
     edge.curved=curve_multiple(help),
     main="Help-Netzwerk",
     sub="n=38, KK-Algorithmus")
```

Wir haben jetzt aus dem selben Netzwerk zwei Netzwerke generiert. Auswahlkriterium war ein Edge-Attribut, das zwei Werte angenommen hat. 

```{r Übung: Visualisieren Sie das Beziehungsnetzwerk Love}

# Netzwerk einlesen
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")
edgematrix <-as.matrix(el)
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)
s

# Wie geht es jetzt weiter?

```



```{r Gegenüberstellung von Gesamtnetzwerk sowie Teilnetzwerken}

# Netzwerk einlesen
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")
edgematrix <-as.matrix(el)
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)
s


# definiert, dass 3 Abbildungen in einer Zeile stehen
par(mfrow=c(1,3), mar=c(0,0,2,1)) 

work <- subgraph.edges(s, E(s)[relation==1]) 
help <- subgraph.edges(s, E(s)[relation==2]) 
love <- subgraph.edges(s, E(s)[relation==3]) 

plot(help,
     edge.arrow.size=.3,
     layout=layout_with_kk,
     edge.color="green",
     edge.curved=.2,
     edge.curved=curve_multiple(help),
     main="Ratsuche-Netzwerk",
     sub="n=38, KK-Algorithmus")

plot(work,
     edge.arrow.size=.3,
     layout=layout_with_kk,
     edge.color="blue",
     edge.curved=.2,
     edge.curved=curve_multiple(work),
     main="Zusammenarbeits-Netzwerk",
     sub="n=38, KK-Algorithmus")


plot(love,
     edge.arrow.size=.3,
     layout=layout_with_kk,
     edge.color="red",
     edge.curved=.2,
     edge.curved=curve_multiple(work),
     main="Liebes-Netzwerk",
     sub="n=38, KK-Algorithmus")

# setzt die Darstellung wieder auf eine Abbildung zurück
par(mfrow=c(1,1), mar=c(0,0,2,2)) 

```

## Teilnetzwerke nach spezifischen Edge-Attributen wie gewichtet

Das Unterstützungsnetzwerk help lässt sich beispielsweise nun auch nach der Stärke der Beziehungen unterteilen:

```{r Aufteilen und Zusammenführen von Teilnetzwerken (subgraph.edges)}

# unterteilt das Netzwerk in das Hilfsnetzwerk h1 mit einem Gewicht von 1
h1 <- subgraph.edges(help, E(help)[weight==1])
# analog dazu das Hilfsnetzwerk mit einem Gewicht von 3
h3 <- subgraph.edges(help, E(help)[weight==3])
# Vergleich der beiden Netzwerke
h1
h3
# jedes Netzwerk hat jetzt genau 38 Knoten mit 38 Kanten

par(mfrow=c(1,3), mar=c(0,0,2,1)) # definiert, dass 3 plots in einer Zeile stehen

plot(h3,
     layout=layout_with_kk,
     edge.color="blue",
     edge.arrow.size=.3,
     edge.weight=3,
     main="Ratsuche-Netzwerk (Gewicht 3)",
     sub="n=38, Beziehungsstärke 3 (Gewicht), erste Nennung")

plot(h1, layout=layout_with_kk,
     main="Ratsuche-Netzwerk (Gewicht 1)",
     edge.color="blue",
     edge.arrow.size=.3,
     sub="n=38, Beziehungsstärke 1 (Gewicht), zweite Nennung")

# die beiden getrennten Netzwerke lassen sich nun einfach mit einer Addition wieder in das ursprüngliche Netzwerk zurückversetzen:

hk <- h1 + h3
hk
plot(hk, layout=layout_with_kk,
     main="Ratsuche-Netzwerk (gesamt)",
     edge.color="grey80",
     edge.arrow.size=.3,
     sub="n=38, 76 Kanten")

# setzt die Ansicht wieder auf einen Graph pro Zeile zurück
par(mfrow=c(1,1), mar=c(0,0,1,2))

```

Der Vergleich der Netzwerke h3 und h1 zeigt deutliche Unterschiede in den Präferenzen. Beispielsweise hat Knoten 18 eine sehr viel stärkere Relevanz bei der ersten Nennung als bei der zweiten. Bei der zweiten Nennung h1 verteilt sich das Netzwerk noch viel deutlicher mit den Knoten 30 und 36 als relevante Nennungen.

Das Netzwerk ist untypisch für natürliche Netzwerke, weil die Antwortmöglichkeiten für help und work erzwungen wurden (es mussten immer zwei Kontakte angegeben werden. Anders sieht dies bei den Beziehungen des Netzwerks love aus

```{r Übung: Selektieren Sie das Netzwerk love}

# Netzwerk einlesen
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")
edgematrix <-as.matrix(el)
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)
s

# Wie geht es jetzt weiter?
# Selektieren Sie das Netzwerk love und vergleichen die drei unterschiedlichen Beziehungsmuster (Beziehung, Tinder, Crush) im Netzwerk (siehe Codebuch).

```


# Selektion von Netzwerken nach Vertex-Attributen

## Selektion von Teilnetzwerken nach Vertex-Attributen

Wenn Netzwerke nach Vertex-Attributen unterteilt werden benötigen sie einen anderen Befehl als bei den Edge-Attributen. Am einfachsten ist es die unbenötigten Knoten (und deren Kanten) mit dem Befehl *delete_vertices()* zu löschen. Nachfolgend interessieren uns nur weibliche Knoten im Ratsuche-Netzwerk.

```{r Teilnetzwerke nach Vertex-Attributen (delete_vertices)}
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")
edgematrix <-as.matrix(el)
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)
s

# Zeigt uns die Vertex-Attribute des Unternetzwerks "help" an.
vertex_attr(s)

# Wir wollen nun wissen, wie das Ratsuche-Netzwerk unter Frauen aussieht:
s_fem <- delete_vertices(s, V(s)[sex > "1"]) # löscht männlich und divers
s_fem
plot(s_fem, layout=layout_with_kk,
     main="Netzwerk, nur weiblich",
     edge.color="grey80",
     edge.arrow.size=.3,
     vertex.color="pink",
     sub="n=29, 110 Kanten")

```

```{r Übung: Nur männliche Knoten im Studiengang}
# Wir lesen das Netzwerk neu ein:
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")
edgematrix <-as.matrix(el)
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)
s

# Zeigt uns die Vertex-Attribute des Unternetzwerks "help" an.
vertex_attr(s)

# Wir wollen nun wissen, wie das Ratsuche-Netzwerk unter Frauen aussieht:
s_fem <- delete_vertices(s, V(s)[sex > "1"]) # löscht männlich und divers
s_fem
plot(s_fem, layout=layout_with_kk,
     main="Netzwerk, nur weiblich",
     edge.color="grey80",
     edge.arrow.size=.3,
     vertex.color="pink",
     sub="n=29, 110 Kanten")

```


# Knoten aufgrund von Vertex-Attributen löschen
Oft ist es aus Gründen der Übersichtlichkeit empfehlenswert, manche Knoten zu löschen. Damit lassen sich über mehrere Schritte spezifische kleine Netzwerke aus einem großen Netzwerk entwickeln. Uns interessiert jetzt ein das weibliche Unterstützungsnetzwerk von Personen, sich sich stark unterstützen und die über 23 Jahre alt sind. Wie sieht die Beziehung zwischen diesen Personen aus?


```{r Spezifische Teilnetzwerke schrittweise erstellen}
# Wir lesen das Netzwerk neu ein:
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")
edgematrix <-as.matrix(el)
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)
s

# Schritt 1: Trennung in das Unterstützungsnetzwerk
help <- subgraph.edges(s, E(s)[relation==2]) 
help

# Schritt 2: Selektion weight=3 
help_strong <- subgraph.edges(help, E(help)[weight==3])

# Wir wollen nun wissen, wie das Ratsuche-Netzwerk unter Frauen aussieht:
fem <- delete_vertices(help_strong, V(help_strong)[sex != "1"]) # löscht alle nicht weiblichen Knoten

plot(fem,
     layout=layout_with_kk,
     main="Unterstützungsnetzwerk weiblich",
     edge.color="grey80",
     edge.arrow.size=.3,
     vertex.color="pink",
     sub="weiblich, starke Beziehung")


fem_old <- delete_vertices(fem, V(fem)[age < "3"])
fem_old
plot(fem_old, layout=layout_with_kk,
     main="Unterstützungsnetzwerk weiblich (fem_old)",
     edge.color="grey80",
     edge.arrow.size=.3,
     vertex.color="pink",
     sub="weiblich, Alter über 23, starke Beziehung")

# Es zeigt sich, dass nur eine (reziproke) Beziehung beim weiblichen Unterstützungsnetzwerk der über 23-jährigen übrig bleibt. Um diese Dyade besser darzustellen können alle isolates, also Knoten, die nicht miteinander verbunden sind, gelöscht werden.

# der Befehl delete.vertices löscht alle Knoten aus dem Netzwerk fem_old, die einen degree-Wert von 0 haben, also mit keinem anderen Knoten verbunden sind. 
fem_old2 <- delete.vertices(fem_old, degree(fem_old)==0)
fem_old2

plot(fem_old2, layout=layout_with_kk,
     main="Unterstützungsnetzwerk weiblich (fem_old2)",
     edge.arrow.size=.5,
     edge.width=E(s)$weight,
     edge.color="pink",
     vertex.size=30,
     vertex.color="pink",
     vertex.color.frame="white",
     sub="weiblich, Alter über 23, starke Beziehung, ohne Isolates")



```


## Egonetzwerke als Teilnetzwerke erstellen

Manchmal ist es hilfreich, bestimmte Knoten aus dem Netzwerk zu extrahieren, um diese genauer zu untersuchen. Damit "zoomt" man auf einen Knoten im Netzwerk. Sie erinnern sich: jedes Netzwerk besteht aus Egos (einzelne Knoten) und deren Alteri. Diese Ego-Netzwerke lassen sich auch einzeln analyisieren. 

 Wir verwenden dafür die Befehle ego_size() und make_ego_graph().

```{r Kapitel 3: Einzelne Ego-Netzwerke isolieren}
# Wir lesen das Netzwerk neu ein:
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")
edgematrix <-as.matrix(el)
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)
s


# zeigt die Knoten mit den meisten Verbindungen, ähnlich wie der degree Wert.
ego_size(s)

# Wir stellen fest, dass Knoten 18 die meisten degrees hat. Deshalb wollen wir ein Ego-Netzwerk aus diesem Graph generieren.
degree(s)

# selektiert aus dem Netzwerk h3 alle Knoten, die mit Knoten 18 über einen Schritt verbunden sind.
king <- make_ego_graph(s, order = 1, nodes = V(s)$name == 18, mode ="all")

# liefert eine Liste der Verbindungen (in diesem Falle alle out/indgree Beziehungen von 18)
king

# liefert einen (nicht besonders aufregenden) Plot des selektierten Ego-Netzwerks "king"

# man braucht diesen Zwischenschrit, damit das igraph-Objekt von king1 hergestellt ist
king1 <- king[[1]]
king1

plot(king1, 
     main="Ego-Netzwerk Knoten 18, erster Grad",
     vertex.color="gold",
     edge.color="grey80",
     edge.arrow.size=.3,
     sub="nur direkte Beziehungen des ersten Grads (15 alteri)")

# Neben den Beziehungen des ersten Grades lassen sich auch Beziehungen des zweiten Grades über das Attribut order setzen:

king2 <- make_ego_graph(s, order = 2, nodes = V(s)$name == 18, mode ="all")
king2 <- king2[[1]]

plot(king2, 
     main="Ego-Netzwerk Knoten 18, 2. Grad",
     vertex.color="orange",
     edge.color="grey80",
     edge.arrow.size=.3,
     sub="Beziehungen des zweiten Grads (21 alteri)")

king3 <- make_ego_graph(h3, order = 3, nodes = V(h3)$name == 18, mode ="all")
king3 <- king3[[1]]

plot(king3, 
     main="Ego-Netzwerk Knoten 18, 3. Grad",
     vertex.color="red",
     edge.color="grey80",
     edge.arrow.size=.3,
     sub="Beziehungen des dritten Grads, 22 alteri")

# erst durch die Einbezierung der Beziehungen des zweiten Grads wird die Beziehungsstruktur innerhalb des Netzwerks sichtbar. 

# Darstellung als Vergleich:

par(mfrow=c(1,3), mar=c(0,0,1,2))
plot(king1, edge.arrow.size=.3, main="Ego_Netzwerk, erster Grad")
plot(king2, edge.arrow.size=.3,  main="Ego_Netzwerk, zweiter Grad")
plot(king3, edge.arrow.size=.3, main="Ego_Netzwerk, dritter Grad")

par(mfrow=c(1,1), mar=c(0,0,1,2))
     
```

# Farben und Labels

igraph greift auf die Visualisierungsparameter des Basispakets von R zurück (siehe dazu etwa ?plot) und ergänzt diese um eigene Visualisierungsparameter 

## Farben

R hat bereits eingebaute Funktionen, die eine Visualisierung erleichtern.

```{r Kapitel 4: Visualisierung Farben}
# ruft die Farben auf, die R standardmässig verwendet
colors()
# ruft neue Farbpaletten auf (ggf. RColorBrewer zunächst installieren)
library(RColorBrewer)
display.brewer.all()
# zeigt verschiedene Farbpaletten
display.brewer.pal(5, "Blues")
display.brewer.pal(10, "Reds")
bp8 <- display.brewer.pal(8, "Blues")
bp8
```


```{r Übung: Erstellen von Farbverläufen}
# Erstellen sie folgende Farbverläufe mit RColorBrewer

# 1) 4 Verläufe von Blau
# 2) 8 Verläufe von Blau
# 3) 12 Verläufe von Blau

```


# Labels und Legenden

Labels sind Beschriftungen, die ein Netzwerk interpretierbar machen. Leider liefert R nur rudimentäre Funktionen, so dass eine sinnvolle Beschriftung und Verfeinerung meisten andere Pakete notwendig macht. Generell wird die Beschriftung über die Funktion legend() erzeugt.
https://stat.ethz.ch/R-manual/R-devel/library/graphics/html/legend.html oder ?legend.

*Visualisierung nach Vertex-Attribut (zwei Farben) mit Legende*

```{r Kapitel 4: Legende hinzufügen für Farben}
# Wir lesen unser Netzwerk ein
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")
edgematrix <-as.matrix(el)
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)
s

# Es soll das Geschlecht im Netzwerk visualisiert und in der Legende dargestellt werden. Dazu ist es notwendig, die Codierung im Netzwerk zu kennen. Als Vorbereitung müssen zwei Vektoren erstellt werden, die in der Legende aufgegriffen werden: die Farben (colrs) und die Verteilung des Geschlechts (sex), damit die legende darauf zugreifen kann. 

# Zunächst definiert der Vector colrs das Farbspektrum der verwendeten Farben. Da wir wissen, dass wir bei $sex nur drei Werte haben (männlich, weiblich, divers) brauchen wir auch zwei Werte. Die direkten Farbpaletten sind hier hinterlegt: http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf.

# Wir legen drei Farben als Vektor fest
col_sex <- c("pink", "lightblue", "orange")

# Wir legen eine Vektor an, der die drei Möglichkeiten des Geschlechts abbildet
sex <- c("weiblich", "männlich", "divers")

# WICHTIG: die Reihenfolge von Farbe und Geschlecht korrespondiert mit der Nennung des Vertex-Attributs sex (1=weiblich, 2=männlich, 3=divers)
V(s)$color <- colrs[V(s)$sex] # selektiert die Vertex-Farbe nach den Farben im Vector colrs

# Abbildung nach Geschlecht
plot(s, 
     edge.arrow.size=.3, # Pfeilspitze auf .3
     edge.color="grey70", # Kantenfarbe 70% Grau
     layout=layout_with_kk, # Layout-Algorithmus Kamada-Kawai
     vertex.frame.color=NA, # keine Ränder bei den Vertices anzeigen
     vertex.label=NA, # keine Labels anzeigen (männlich/weiblich steht im Zentrum)
     edge.curved=.2, # Kantenkrümmung von .2
     edge.curved=curve_multiple(s), # Kanten sollen sich nicht überlagern
     main="Netzwerk nach Geschlecht", # Hauptüberschrift
     sub="n=38") # Unterüberschrift

# Die Legende wird händisch hinzugefügt. Die einzelnen Parameter definieren, wie die Legende aussehen soll.

legend(x=1, # Position auf der X-Achse
       y=-1, # Position auf der Y-Achse
       legend = sex, # ausgegeben wird der Vector "geschlecht"
       col = colrs, # Farbcodierung nach Vector colrs
       text.col= colrs, # Farbe der Legende in der Farbe des Vectors
       bty = "n", # verhindert, dass eine Box gezogen wird
       pch=20, # plotting characters: definiert einen Kreis (siehe ?graphics)
       pt.cex = 2, # definiert die Textgröße
       cex = 1, # skaliert die gesamte Legende
       inset = c(0.1, 0.1) # rückt die Legende leicht ein.
       )

```

```{r Übung: Visualisierung mit Legende erstellen}

# Erstellen Sie aus unserem Netzwerk eine Visualisierung mit Legende
# 1) Haarfarbe
# 2) Augenfarbe
# 3) Alter 

# Wählen Sie für die Visualisierung eine jeweils passende Farbskala aus.
# 
# 

```

# Layout und Visualisierung

Bei igraph sind viele Algorithmen bereits vorgegeben, nicht alle sind sinnvoll für die Darstellung eines Netzwerks. Für natürliche Netzwerke sind sogenannte spring-embedded Darstellungen sinnvoll. Sie gehen von phsyikalischen Gesetzen der Anziehung und Abstoßung zwischen den Knoten aus. Vereinfacht gesagt: je mehr Kanten ein Knoten hat, desto mehr Anziehungskraft übt er auf andere Knoten aus.

Generell sollten Sie Kamada-Kawai (kk) verwenden, wenn mehrere Netzwerke miteinander verglichen werden sollen. KK legt die Position der einzelnen Knoten immer an die gleiche Stelle, so dass Vergleiche leichter möglich sind. Ansonsten sind empfehlenswert fr (Fruchterman-Rheingold) oder layout_nicely (wählt automatisch die beste Variante). Mit dem untenstehenden Skript können Sie ein Netzwerk schnell in verschiedenen Algorithmen darstellen.

Achtung: jeder Algorithmus ist für einen bestimmten Fall geschrieben und funktioniert nach unterschiedlichen Gesetztmäßigkeiten. Um die Interpretation nicht zu verzerren sollten Sie deshalb bei einer Darstellung für den Vergleich bleiben.

*Darstellungen in der Übersicht*

```{r Nutzung verschiedener Algorithmen}

# Wir lesen unser Netzwerk ein:
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")
edgematrix <-as.matrix(el)
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)
s

# Code von Katherine Ognyanova via kateto.net, um verschiedene Visualisierungen darzustellen:

# entfernt weitere Darstellungen, die wir nicht brauchen
layouts <- grep("^layout_", ls("package:igraph"), value=TRUE)[-1]

# legt ein Layout fest
layouts <- layouts[!grepl("bipartite|merge|norm|sugiyama|tree", layouts)]

# definiert eine 3x3 Felder Matrix für die Darstellung
par(mfrow=c(3,3), mar=c(1,1,1,1)) 
for (layout in layouts) {
print(layout)
l <- do.call(layout, list(s))

# plottet das Netzwerk s auf die vorgegebenen Layout-Angaben
plot(s, 
     edge.arrow.mode=.2, 
     layout=l, 
     main=layout) }

# setzt die Darstellung wieder auf eine einzelne Abbildung zurück
par(mfrow=c(1,1), mar=c(0,0,0,1))
 
```

```{r Netzwerk entzerren }
# Wir lesen unser Netzwerk ein:
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")
edgematrix <-as.matrix(el)
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)
s

E(s)$arrow.size <- .3 

# layout parameter festlegen für Kamada-Kawai

l <- layout_with_kk(s)
l <- norm_coords(l, ymin=-1, ymax=1, xmin=-1, xmax=1)

par(mfrow=c(2,2), mar=c(3,3,3,3))
plot(s, rescale=F, layout=l*0.4)
plot(s, rescale=F, layout=l*0.8)
plot(s, rescale=F, layout=l*1.2)
plot(s, rescale=F, layout=l*1.6)

# Beste Visualisierung ist mit Faktor 1.2
par(mfrow=c(1,1), mar=c(2,2,2,2))
plot(s, 
     rescale=F, 
     layout=l*1.2, 
     main="maximal entzerrte Darstellung",
     sub="KK-Algorithmus, Layout Faktor 1.3")

```


# Visualisierungsparameter
## Seite einrichten

Igraph bezieht sich auf den generischen plot() Befehl in R, d.h. die Parameter für die Funktion werden von dort übernommen, siehe ?plot() und für eine ausführlichere Darstellung etwa
https://www.statmethods.net/advgraphs/parameters.html

Ein wichtiger Befehl für die saubere Darstellung von Grafiken ist im Befehl par() festgelegt. Hier werden Parameter für die Visualisierung festgelegt. 

Das Argument mar (für margin) definiert die Seitenränder in Zeilen (lines), die Reihenfolge ist unten, links, oben rechts: es müssen immer vier Werte definiert werden. Beispielsweise definiert der Befehl par(mar=c(5,3,6,2) folgende Abstände:
unten = 5 Zeilen
links = 3 Zeilen
oben = 6 Zeilen
rechts = 2 Zeilen

Der Vektor mfrow=c() gibt an, wie viele Spalten und Zeilen in einer Abbildung definiert werden, wobei der erste Wert die Zeile und der zweite Wert die Spalten angibt. Damit lassen sich mehrere Abbildungen vergleichen. Wir verwenden die Kombination von beiden Argumenten bzw. dem Vektor, um die Abbildungen darzustellen.

Der Befehl *par(mfrow=c(1,2), mar=c(0,0,2,0))*

definiert, dass zwei Abbildungen nebeinander (in einer Zeile) mit einem Zeilenabstand von 2 nach oben festgelegt werden. 

Da dies ein fester Parameter ist, bleibt er für alle Abbildungen erhalten, bis er zurückgesetzt wird. Dazu reicht ein generischer Code am Ende einer Visualisierung:

par(mfrow=c(1,1), mar=c(1,1,1,1))

## Export einer Visualisierung

Wenn Sie einen plot/Visualisierung für ein anderes Programm nutzen wollen, stehen umfangreiche Möglichkeiten zur Verfügung. Achtung: die Plots aus einem Notebook sind nicht "production ready". Führen Sie deshalb den Code und Plot direkt in der Console aus. Über die Funktion Plots > Export können sie verschiedene Möglichkeiten für den Export definieren, von Print- bis Webexport.


##############################
# Challenge Visualisierung 1 #
# "Finding love in data"     #
##############################

Sie sind auf der Suche nach den Paarbeziehungen im Datensatz. Als investigativer Journalist haben Sie den Auftrag bekommen, folgende Visualisierungen zu erstellen:

Dazu müssen Sie alle Fähigkeiten, die Sie heute vormittag erlernt haben, einsetzen. Es ist alles lösbar mit dem Skript aus Blocktermin 1. Sie müssen dazu die Codierung des Datensatzes anschauen:
https://github.com/hdm-crpr/226305/blob/master/data/crpr2/codebuch.md

1) Welche Paarbeziehungen sind homosexuell? (Als Paarbeziehung gilt eine reziproke Beziehung, als homosexuell die Beziehung zum gleichen Geschlecht.). Reduzieren Sie das Netzwerk nur auf homosexuelle Paarbeziehungen! (Dazu benötigen Sie mehrere Schritte)

2) Gibt es polyamore Beziehungen in dem Sample? (Polyamorie ist definiert als gleichzeitige Paarbeziehung zu mehreren Menschen, egal welchen Geschlechts).

3) Wer hat die meisten Crushes? Visualisieren Sie das Ego-Netzwerk der Person, die die meisten Crushes hat. Erstellen Sie dazu eine Visualisierung mit Legende, die zwischen anderen Beziehungen unterscheidet.

Bitte erstellen Sie die drei Visualisierungen und laden diese auf Moodle > Blocktermin > Übungsdateien hoch.

Optional:
4) Wird Tinder eher von jüngeren oder älteren genutzt?
5) Spielen Haar- und Augenfarbe eine Rolle?
6) Erstellen Sie das Ego-Netzwerk von der Person, die am meisten Crushes hat.


